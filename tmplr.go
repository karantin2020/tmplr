package main

import (
	"os"
	// "regexp"
	"fmt"
	"io/ioutil"
	"log"
	"path/filepath"
	"strings"

	"github.com/jawher/mow.cli"
	"github.com/karantin2020/fasttemplate"
)

var (
	root = "./tmpls"
)

var (
	tmpl *string
	pkg  *string
	out  *string
	// subpkg    *string
	apn       *bool
	tags      *bool
	row_tags  *[]string
	file_tags *string
)

func main() {
	flags := cli.App("tmplr", "Template renderer to use in golang code generation")
	flags.Spec = "-t -g | ([-ap]... -o TGS... | FILE)"
	flags.Version("v version", "tmplr 0.2.0")
	apn = flags.BoolOpt("a append", false, "append result of template render to file or not")
	tags = flags.BoolOpt("g tags", false, "print all tags from template")
	tmpl = flags.StringOpt("t template", "", "template to execute; may be in form file name or destination but always without .tmpl suffix")
	out = flags.StringOpt("o out", "", "output file")
	pkg = flags.StringOpt("p pkg", "", "output package")
	// subpkg = flags.StringOpt("s subpkg", "", "output subpkg name")
	row_tags = flags.Strings(cli.StringsArg{
		Name: "TGS",
		Desc: "Tags to parse in format tag:value",
	})
	file_tags = flags.StringArg("FILE", "", "Source file with tags to parse")
	flags.Action = worker

	flags.Run(os.Args)
}

func worker() {
	if *tmpl == "" {
		log.Fatal("didn't pass template name")
		os.Exit(1)
	} else {
		if hasSlash := strings.Contains(*tmpl, "/"); hasSlash {
			root = ""
		}
	}
	var templString string

	if hasSuffix := strings.HasSuffix(*tmpl, ".tmpl"); !hasSuffix {
		*tmpl = *tmpl + ".tmpl"
	}
	if ft, err := ioutil.ReadFile(filepath.Join(root, *tmpl)); err != nil {
		log.Fatal(err)
	} else {
		templString = string(ft)
	}
	templInst := fasttemplate.New(templString, "{{", "}}")
	if *tags {
		fmt.Println(unique(templInst.Tags))
		os.Exit(0)
	}

	pkgCnt := "package main\n\n"
	if *pkg != "" {
		pkgCnt = fmt.Sprintf("package %s\n\n", *pkg)
	}

	if *out == "" {
		log.Fatal("didn't pass output file name")
		os.Exit(1)
	}
	// if *subpkg != "" {
	// 	pkgCnt = fmt.Sprintf("package %s\n\n", *subpkg)
	// 	*pkg = ""
	// }

	m := make(map[string]interface{})
	for _, arg := range *row_tags {
		vals := strings.Split(arg, ":")
		if len(vals) != 2 || vals[0] == "" || vals[1] == "" {
			continue
		}
		m[vals[0]] = vals[1]
	}
	tag_list := make([]string, 0, len(*row_tags))
	for k := range m {
		tag_list = append(tag_list, k)
	}

	if *pkg != "" {
		os.Mkdir(*pkg, os.ModePerm)
	}

	for _, tag := range templInst.Tags {
		if _, ok := stringInSlice(tag, tag_list); !ok {
			fmt.Println("Warning: Not all template tags are filled with values:", tag)
			os.Exit(1)
		}
	}
	s := ""
	if !(*apn) {
		s = `// This code is generated by 'templr'
// DO NOT EDIT

`
	}
	if !(*apn) {
		s = s + pkgCnt
	}

	if len(templInst.Tags) == 0 {
		s = s + templString
	} else {
		s = s + templInst.ExecuteString(m)
	}

	// path := filepath.Join((*pkg), (*out)+".go")
	path := *out
	if hasSuffix := strings.HasSuffix(*out, ".go"); !hasSuffix {
		path = path + ".go"
	}
	if hasSlash := strings.Contains(*out, "/"); !hasSlash {
		path = filepath.Join(*pkg, path)
	}
	var fileFlag int
	if *apn {
		fileFlag = os.O_CREATE | os.O_WRONLY | os.O_APPEND
	} else {
		fileFlag = os.O_CREATE | os.O_TRUNC | os.O_WRONLY
	}

	if f, err := os.OpenFile(path, fileFlag, 0666); err != nil {
		log.Fatal(err)
	} else {
		defer f.Close()
		if _, err := f.WriteString(s); err != nil {
			log.Fatal(err)
		}
	}
}

func stringInSlice(a string, list []string) (int, bool) {
	for i, b := range list {
		if b == a {
			return i, true
		}
	}
	return 0, false
}

func appendIfMissing(slice []string, i string) []string {
	for _, ele := range slice {
		if ele == i {
			return slice
		}
	}
	return append(slice, i)
}

func unique(slice []string) []string {
	var res []string
	for _, st := range slice {
		res = appendIfMissing(res, st)
	}
	return res
}
